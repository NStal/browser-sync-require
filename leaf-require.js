// Generated by CoffeeScript 1.8.0
(function() {
  
/**
 * Implementation of base URI resolving algorithm in rfc2396.
 * - Algorithm from section 5.2
 *   (ignoring difference between undefined and '')
 * - Regular expression from appendix B
 * - Tests from appendix C
 *
 * @param {string} uri the relative URI to resolve
 * @param {string} baseuri the base URI (must be absolute) to resolve against
 */

URI = function(){
    function resolveUri(sUri, sBaseUri) {
    if (sUri == '' || sUri.charAt(0) == '#') return sUri;
    var hUri = getUriComponents(sUri);
    if (hUri.scheme) return sUri;
    var hBaseUri = getUriComponents(sBaseUri);
    hUri.scheme = hBaseUri.scheme;
    if (!hUri.authority) {
        hUri.authority = hBaseUri.authority;
        if (hUri.path.charAt(0) != '/') {
        aUriSegments = hUri.path.split('/');
        aBaseUriSegments = hBaseUri.path.split('/');
        aBaseUriSegments.pop();
        var iBaseUriStart = aBaseUriSegments[0] == '' ? 1 : 0;
        for (var i in aUriSegments) {
            if (aUriSegments[i] == '..')
            if (aBaseUriSegments.length > iBaseUriStart) aBaseUriSegments.pop();
            else { aBaseUriSegments.push(aUriSegments[i]); iBaseUriStart++; }
            else if (aUriSegments[i] != '.') aBaseUriSegments.push(aUriSegments[i]);
        }
        if (aUriSegments[i] == '..' || aUriSegments[i] == '.') aBaseUriSegments.push('');
        hUri.path = aBaseUriSegments.join('/');
        }
    }
    var result = '';
    if (hUri.scheme   ) result += hUri.scheme + ':';
    if (hUri.authority) result += '//' + hUri.authority;
    if (hUri.path     ) result += hUri.path;
    if (hUri.query    ) result += '?' + hUri.query;
    if (hUri.fragment ) result += '#' + hUri.fragment;
    return result;
    }
    uriregexp = new RegExp('^(([^:/?#]+):)?(//([^/?#]*))?([^?#]*)(\\?([^#]*))?(#(.*))?');
    function getUriComponents(uri) {
    var c = uri.match(uriregexp);
    return { scheme: c[2], authority: c[4], path: c[5], query: c[7], fragment: c[9] };
    }
    var URI = {}
    URI.resolve = function(base,target){
        return resolveUri(target,base);
    }
    URI.normalize = function(url){
        return URI.resolve("",url);
    }
    return {URI:URI}
}();
  var Context, Script, exports,
    __slice = [].slice;

  Context = (function() {
    Context.id = 0;

    Context.instances = [];

    Context.getContext = function(id) {
      return this.instances[id];
    };

    Context._httpGet = function(url, callback) {
      var XHR;
      XHR = new XMLHttpRequest();
      XHR.open("GET", url, true);
      XHR.onreadystatechange = (function(_this) {
        return function(err) {
          if (XHR.readyState === 4) {
            if (XHR.status !== 200) {
              callback(new Error("Network Error status code " + XHR.status));
              return;
            }
            callback(null, XHR.responseText);
          }
          if (XHR.readyState === 0) {
            return callback(new Error("Network Error"));
          }
        };
      })(this);
      return XHR.send();
    };

    function Context(option) {
      if (option == null) {
        option = {};
      }
      this.id = Context.id++;
      Context.instances[this.id] = this;
      this.globalName = "LeafRequire";
      this.localStoragePrefix = option.localStoragePrefix || this.globalName;
      this.dry = option.dry || false;
      this.ready = false;
      this.scripts = [];
      this.store = {
        files: {}
      };
      this.init({
        root: option.root,
        version: option.version,
        name: option.name,
        debug: option.debug
      });
    }

    Context.prototype.init = function(option) {
      this.root = option.root || this.root || "./";
      if (this.root[this.root.length - 1] !== "/") {
        this.root += "/";
      }
      this.version = option.version || this.version || "0.0.0";
      this.name = option.name || this.name || "leaf-require";
      this.debug = option.debug || this.name || false;
      return this.enableSourceMap = option.enableSourceMap || this.debug || false;
    };

    Context.prototype.use = function() {
      var file, files, _i, _len, _results;
      files = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      _results = [];
      for (_i = 0, _len = files.length; _i < _len; _i++) {
        file = files[_i];
        _results.push(this.scripts.push(new Script(this, file)));
      }
      return _results;
    };

    Context.prototype._debug = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (this.debug) {
        return console.debug.apply(console, args);
      }
    };

    Context.prototype.getScript = function(path) {
      var script, _i, _j, _len, _len1, _ref, _ref1;
      _ref = this.scripts;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        script = _ref[_i];
        if (script.scriptPath === path) {
          return script;
        }
      }
      if (path.lastIndexOf(".js") !== path.length - ".js".length) {
        _ref1 = this.scripts;
        for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
          script = _ref1[_j];
          if (script.scriptPath === path + ".js") {
            return script;
          }
        }
      }
      return null;
    };

    Context.prototype.getRequire = function(path) {
      var script;
      script = this.getScript(path);
      return function(_path) {
        return script.require(_path);
      };
    };

    Context.prototype.setRequire = function(path, module, exports, __require) {
      var script;
      script = this.getScript(path);
      return script.setRequire(module, exports, __require);
    };

    Context.prototype.loadConfig = function(config, callback) {
      var e;
      if (callback == null) {
        callback = function() {};
      }
      if (typeof config === "string") {
        return this.setConfigRemote(config, callback);
      } else {
        try {
          this.setConfigSync(config);
          return callback();
        } catch (_error) {
          e = _error;
          return callback(e);
        }
      }
    };

    Context.prototype.toConfig = function() {
      return {
        name: this.name,
        version: this.version,
        debug: this.debug,
        js: {
          root: this.root,
          files: this.scripts.map(function(script) {
            return {
              hash: script.hash,
              path: script.path
            };
          })
        }
      };
    };

    Context.prototype.setConfigRemote = function(src, callback) {
      return Context._httpGet(src, (function(_this) {
        return function(err, content) {
          var config, e;
          if (err) {
            console.error(err);
            callback(new Error("fail to get configs " + src + " due to network error"));
            return;
          }
          try {
            config = JSON.parse(content);
            _this.setConfigSync(config);
            return callback(null);
          } catch (_error) {
            e = _error;
            return callback(e);
          }
        };
      })(this));
    };

    Context.prototype.setConfigSync = function(config) {
      var file, files, js, _i, _len;
      this.hasConfiged = true;
      js = config.js || {};
      files = js.files || [];
      this.init({
        name: config.name,
        root: js.root,
        version: config.version,
        debug: config.debug
      });
      for (_i = 0, _len = files.length; _i < _len; _i++) {
        file = files[_i];
        this.use(file);
      }
      return this.store.config = config;
    };

    Context.prototype.require = function(path, fromScript) {
      var realPath, script, url;
      url = URI.URI;
      if (fromScript) {
        realPath = url.resolve(fromScript.scriptPath, path);
      } else {
        realPath = url.normalize(path);
      }
      if (realPath.indexOf("/") === 0) {
        realPath = realPath.substring(1);
      }
      script = this.getScript(realPath);
      if (!script) {
        throw new Error("module " + realPath + " not found");
      }
      return script.beRequired();
    };

    Context.prototype.restoreCache = function() {
      var e, _base;
      try {
        this.store = JSON.parse(window.localStorage.getItem("" + this.localStoragePrefix + "/cache") || "{}");
      } catch (_error) {
        e = _error;
        this.store = {};
      }
      if (this.store.config) {
        this.loadConfig(this.store.config);
      }
      if ((_base = this.store).files == null) {
        _base.files = {};
      }
    };

    Context.prototype.isCacheAtomic = function() {
      var files, script, _i, _len, _ref;
      if (!this.store) {
        return false;
      }
      files = this.store.files || {};
      _ref = this.scripts;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        script = _ref[_i];
        if (script.hash && script.loadPath && files[script.loadPath] && files[script.loadPath].hash === script.hash) {
          continue;
        } else {
          return false;
        }
      }
      return true;
    };

    Context.prototype.clearCache = function(version) {
      return window.localStorage.removeItem("" + this.localStoragePrefix + "/cache");
    };

    Context.prototype.compactCache = function(option) {
      var script, _i, _j, _len, _len1, _ref, _ref1;
      if (option == null) {
        option = {};
      }
      if (this.isCacheAtomic()) {
        return false;
      }
      if (!this.isReady) {
        return false;
      }
      if (this.hasConfiged || option.exportConfig) {
        this.store.config = this.toConfig();
      }
      this.store.files = {};
      _ref = this.scripts;
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        script = _ref[_i];
        if (!script.scriptContent) {
          return false;
        }
      }
      _ref1 = this.script;
      for (_j = 0, _len1 = _ref1.length; _j < _len1; _j++) {
        script = _ref1[_j];
        script._saveScriptContentToStore(script.scriptContent);
      }
      return true;
    };

    Context.prototype.load = function(option, callback) {
      var loadFailure;
      if (option == null) {
        option = {};
      }
      if (typeof option === "function") {
        callback = option;
      }
      loadFailure = false;
      return this.scripts.forEach((function(_this) {
        return function(script) {
          return script.load(function(err) {
            var allReady;
            if (loadFailure) {
              return;
            }
            if (err) {
              loadFailure = true;
              callback(new Error("fail to load script " + script.loadPath));
              return;
            }
            allReady = _this.scripts.every(function(item) {
              if (!item.isReady && !(item.dryReady && _this.dry)) {
                return false;
              }
              return true;
            });
            if (allReady) {
              _this.isReady = true;
              return callback();
            }
          });
        };
      })(this));
    };

    Context.prototype.saveCache = function(option) {
      var store;
      if (option == null) {
        option = {};
      }
      store = this.store || {};
      if (this.hasConfiged || option.exportConfig) {
        store.config = this.toConfig();
      }
      this._debug("save cache", store, "" + this.localStoragePrefix + "/cache");
      return window.localStorage.setItem("" + this.localStoragePrefix + "/cache", JSON.stringify(store || {}));
    };

    Context.prototype.saveCacheDelay = function() {
      if (this._saveCacheDelayTimer) {
        clearTimeout(this._saveCacheDelayTimer);
      }
      return this._saveCacheDelayTimer = setTimeout(((function(_this) {
        return function() {
          return _this.saveCache();
        };
      })(this)), 0);
    };

    Context.prototype.clone = function(option) {
      var c;
      c = new Context(option);
      c.loadConfig(this.toConfig());
      c.scripts = this.scripts.map(function(script) {
        return script.clone(c);
      });
      return c;
    };

    return Context;

  })();

  Script = (function() {
    function Script(context, file) {
      var url;
      this.context = context;
      url = URI.URI;
      if (typeof file === "string") {
        this.path = file;
      } else {
        this.path = file.path;
        this.hash = file.hash || null;
      }
      this.scriptPath = url.normalize(this.path);
      this.loadPath = url.resolve(this.context.root, file.loadPath || this.path);
      this._debug = this.context._debug.bind(this);
    }

    Script.prototype.clone = function(context) {
      var prop, s, _i, _len, _ref;
      s = new Script(context, {
        path: this.path,
        hash: this.hash,
        loadPath: this.loadPath
      });
      _ref = ["isReady", "_module", "_exports", "_require", "_isRequiring", "exports", "scriptContent"];
      for (_i = 0, _len = _ref.length; _i < _len; _i++) {
        prop = _ref[_i];
        s[prop] = this[prop];
      }
      return s;
    };

    Script.prototype._restoreScriptContentFromStore = function() {
      if (this.context.store && this.context.store.files) {
        return this.context.store.files[this.loadPath];
      }
      return null;
    };

    Script.prototype._saveScriptContentToStore = function(content) {
      this._debug("save to " + this.loadPath + " with hash " + this.hash + " ??");
      return this.context.store.files[this.loadPath] = {
        hash: this.hash,
        content: content
      };
    };

    Script.prototype.require = function(path) {
      return this.context.require(path, this);
    };

    Script.prototype.setRequire = function(module, exports, __require) {
      this._module = module;
      this._exports = exports;
      this._require = __require;
      this.isReady = true;
      if (this._loadCallback) {
        return this._loadCallback();
      }
    };

    Script.prototype.beRequired = function() {
      if (this.exports) {
        return this.exports;
      }
      if (this._isRequiring) {
        return this._module.exports;
      }
      this._isRequiring = true;
      this._require();
      this._isRequiring = false;
      if (this._exports !== this._module.exports) {
        this._exports = this._module.exports;
      }
      this.exports = this._exports;
      return this.exports;
    };

    Script.prototype.load = function(callback) {
      var file;
      this._loadCallback = callback;
      if (this.isReady) {
        callback();
        return;
      }
      file = this._restoreScriptContentFromStore();
      this._debug("try restore " + this.loadPath + " from cache", file);
      this._debug(this.hash, file && file.hash);
      if (file && file.content && !(this.version && this.version !== file.version)) {
        console.debug("return from", this.context.name, this.loadPath);
        this._debug("cache found and do the restore");
        this._debug("" + this.loadPath + " from cache");
        setTimeout(((function(_this) {
          return function() {
            return _this.parse(file.content);
          };
        })(this)), 0);
        return;
      }
      return Context._httpGet(this.loadPath, (function(_this) {
        return function(err, content) {
          if (err) {
            callback(new Error("fail to get " + _this.loadPath));
            return;
          }
          _this.scriptContent = content;
          return _this.parse(content);
        };
      })(this));
    };

    Script.prototype.parse = function(scriptContent) {
      var code, mapDataUrl, script;
      if (this.script) {
        null;
      }
      this._saveScriptContentToStore(scriptContent);
      if (this.context.dry && this._loadCallback) {
        this.dryReady = true;
        this._loadCallback();
        return;
      }
      script = document.createElement("script");
      code = "(function(){\n    var require = " + this.context.globalName + ".getContext(" + this.context.id + ").getRequire('" + this.scriptPath + "')\n    var module = {exports:{}};\n    var exports = module.exports\n    var global = window;\n    var __require = function(){\n\n// " + this.scriptPath + "\n// BY leaf-require\n" + scriptContent + "\n\n}\n" + this.context.globalName + ".getContext(" + this.context.id + ").setRequire('" + this.scriptPath + "',module,exports,__require)\n\n})()";
      if (this.context.debug || this.context.enableSourceMap) {
        mapDataUrl = this.createSourceMapUrl(scriptContent);
        code += "//# sourceMappingURL=" + mapDataUrl;
      }
      this.script = script;
      script.innerHTML = code;
      return document.body.appendChild(script);
    };

    Script.prototype.createSourceMapUrl = function(content) {
      var index, line, map, offset, result, url, _, _i, _j, _len, _ref;
      offset = 9;
      map = {
        "version": 3,
        "file": this.loadPath,
        "sourceRoot": "",
        "sources": [this.loadPath],
        "sourcesContent": [content],
        "names": [],
        "mappings": null
      };
      result = [];
      for (_ = _i = 0; 0 <= offset ? _i < offset : _i > offset; _ = 0 <= offset ? ++_i : --_i) {
        result.push(";");
      }
      _ref = content.split("\n");
      for (index = _j = 0, _len = _ref.length; _j < _len; index = ++_j) {
        line = _ref[index];
        if (index === 0) {
          result.push("AAAA");
        } else {
          result.push(";AACA");
        }
      }
      map.mappings = result.join("");
      url = URL.createObjectURL(new Blob([JSON.stringify(map)], {
        type: "text/json"
      }));
      return url;
    };

    return Script;

  })();

  Context.BestPractice = (function() {
    function BestPractice(option) {
      this.config = option.config || "./require.json";
      this.localStoragePrefix = option.localStoragePrefix;
      this.errorHint = option.errorHint || this.errorHint;
      this.updateConfirm = option.updateConfirm || this.updateConfirm;
      this.debug = option.debug || false;
      this.showDebugInfo = option.showDebugInfo || option.debug || false;
      this.enableSourceMap = option.enableSourceMap || false;
      this.entry = option.entry || "main";
    }

    BestPractice.prototype._debug = function() {
      var args;
      args = 1 <= arguments.length ? __slice.call(arguments, 0) : [];
      if (this.debug || this.showDebugInfo) {
        if (console.debug == null) {
          console.debug = console.log.bind(console);
        }
        return console.debug.apply(console, args);
      }
    };

    BestPractice.prototype.run = function() {
      this.context = new LeafRequire({
        localStoragePrefix: this.localStoragePrefix,
        enableSourceMap: this.enableSourceMap
      });
      if (this.debug) {
        this.context.loadConfig(this.config, (function(_this) {
          return function() {
            return _this.context.load(function() {
              return _this.context.require(_this.entry);
            });
          };
        })(this));
        return;
      }
      this.context.restoreCache();
      if (this.context.hasConfiged) {
        if (this.context.isCacheAtomic()) {
          this._debug("may use cache completely");
        }
        return this.context.load((function(_this) {
          return function(err) {
            _this._debug("has config");
            if (err) {
              _this.errorHint();
              return;
            }
            _this.context.require(_this.entry);
            _this.checkVerionUpdate();
          };
        })(this));
      } else {
        return this.context.loadConfig(this.config, (function(_this) {
          return function(err) {
            if (err) {
              _this.errorHint();
              return;
            }
            return _this.context.load(function(err) {
              if (err) {
                _this.errorHint();
                return;
              }
              _this.context.saveCache();
              return _this.context.require(_this.entry);
            });
          };
        })(this));
      }
    };

    BestPractice.prototype.errorHint = function() {
      return alert("Fail to load application, please reload the webpage. If not work, please contact admin.");
    };

    BestPractice.prototype.updateConfirm = function(callback) {
      var message;
      message = "detect a new version of the app, should we reload";
      return callback(confirm(message));
    };

    BestPractice.prototype.semanticCompare = function(a, b) {
      var as, bs, index, va, vb, _i, _len;
      if (a == null) {
        a = "";
      }
      if (b == null) {
        b = "";
      }
      as = a.split(".");
      bs = b.split(".");
      while (as.length > bs.length) {
        bs.push("0");
      }
      while (bs.length > as.length) {
        as.push("0");
      }
      as = as.map(function(item) {
        return Number(item) || 0;
      });
      bs = bs.map(function(item) {
        return Number(item) || 0;
      });
      for (index = _i = 0, _len = as.length; _i < _len; index = ++_i) {
        va = as[index];
        vb = bs[index];
        if (va > vb) {
          return 1;
        } else if (va < vb) {
          return -1;
        }
      }
      return 0;
    };

    BestPractice.prototype.checkVerionUpdate = function() {
      var checker;
      checker = new Context({
        localStoragePrefix: this.localStoragePrefix,
        dry: true
      });
      this._debug("check config");
      return checker.loadConfig(this.config, (function(_this) {
        return function(err) {
          if (err) {
            console.error(err, "fail to do load config");
            return;
          }
          checker.name = "checker";
          _this._debug("check config loaded");
          if ((_this.semanticCompare(checker.version, _this.context.version)) > 0) {
            _this._debug(_this.context.version, "<", checker.version);
            _this._debug("check config detect updates, load it");
            return checker.load(function(err) {
              if (err) {
                console.error(err, "fail to load updates");
                return;
              }
              _this._debug("updates load complete");
              checker.compactCache();
              checker.saveCache();
              return _this.updateConfirm(function(result) {
                if (result) {
                  return window.location = window.location.toString();
                }
              });
            });
          } else {
            return _this._debug("check config complete, no updates: version " + checker.version);
          }
        };
      })(this));
    };

    return BestPractice;

  })();

  if (!exports) {
    exports = window;
  }

  exports.LeafRequire = Context;

}).call(this);
